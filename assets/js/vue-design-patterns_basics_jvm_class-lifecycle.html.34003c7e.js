"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[5261],{6262:(e,l)=>{l.A=(e,l)=>{const a=e.__vccOpts||e;for(const[e,i]of l)a[e]=i;return a}},7374:(e,l,a)=>{a.r(l),a.d(l,{comp:()=>t,data:()=>s});var i=a(641);const n={},t=(0,a(6262).A)(n,[["render",function(e,l){return(0,i.uX)(),(0,i.CE)("div",null,l[0]||(l[0]=[(0,i.Fv)('<h1 id="一个类完整的生命周期" tabindex="-1"><a class="header-anchor" href="#一个类完整的生命周期"><span>一个类完整的生命周期</span></a></h1><p>一个类完整的生命周期，会经历五个阶段，分别为：<strong>加载、连接、初始化、使用、和卸载</strong>。其中的连接又分为<strong>验证、准备和解析</strong>。</p><h2 id="_1-加载" tabindex="-1"><a class="header-anchor" href="#_1-加载"><span>1. 加载</span></a></h2><p>类的加载阶段就是：找到需要加载的类并把类的信息加载到JVM的方法区中，然后在堆区中实例化一个<code>java.lang.Class</code>对象，作为方法区中这个类的信息的入口。</p><p>类加载其实包括<strong>加载、连接、初始化</strong>三个阶段。类加载强调一个JVM能够直接使用所需的类，所以类必须完成初始化。</p><h3 id="_1-1-类的理论加载方式" tabindex="-1"><a class="header-anchor" href="#_1-1-类的理论加载方式"><span>1.1 类的理论加载方式</span></a></h3><ul><li>据类的全路径名找到相应的class文件，然后从class文件中读取文件内容；（常用）</li><li>从jar文件中读取。另外，还有下面几种方式也比较常用：（常用） <ul><li>从网络中获取：比如10年前十分流行的Applet。</li><li>根据一定的规则实时生成，比如设计模式中的动态代理模式，就是根据相应的类自动生成它的代理类。</li><li>从非class文件中获取，其实这与直接从class文件中获取的方式本质相同。</li></ul></li></ul><h3 id="_1-2-类的实现加载方式" tabindex="-1"><a class="header-anchor" href="#_1-2-类的实现加载方式"><span>1.2 类的实现加载方式</span></a></h3><ul><li><code>Class.forName()</code>： <ul><li>适合需要执行类的静态初始化的情况，常用于JDBC驱动加载。</li></ul></li><li><code>ClassLoader.loadClass()</code>： <ul><li>仅加载类，不触发静态初始化，提供更灵活的类加载控制。</li></ul></li><li><code>Class.newInstance()</code>和<code>Constructor.newInstance()</code>： <ul><li>用于创建类的实例，后者更灵活，可调用指定构造函数。</li></ul></li><li>自定义类加载器： <ul><li>从自定义位置加载类，实现特殊的类加载逻辑，如文件系统或网络加载。</li></ul></li><li><code>ServiceLoader</code>： <ul><li>用于加载服务提供者，遵循SPI机制，实现服务发现和加载。</li></ul></li></ul><h2 id="_2-连接" tabindex="-1"><a class="header-anchor" href="#_2-连接"><span>2. 连接</span></a></h2><p>连接阶段分为三个子阶段：<strong>验证、准备、解析</strong>。</p><h3 id="_2-1-验证" tabindex="-1"><a class="header-anchor" href="#_2-1-验证"><span>2.1 验证</span></a></h3><p>进行类的合法性校验。</p><p>会对比如字节码格式、变量与方法的合法性、数据类型的有效性、继承与实现的规范性等等进行检查，确保被加载的类能够正常被JVM运行。</p><h3 id="_2-2-准备" tabindex="-1"><a class="header-anchor" href="#_2-2-准备"><span>2.2 准备</span></a></h3><p>简单说就是分内存、赋初值。</p><p>为类的静态变量分配内存，并设为JVM默认的初值；对于非静态的变量，则不会为它们分配内存。</p><p><strong>注意</strong>：设置初始值为JVM默认初值，而不是程序设定。规则如下：</p><ul><li>基本类型（<code>int</code>、<code>long</code>、<code>short</code>、<code>char</code>、<code>byte</code>、<code>boolean</code>、<code>float</code>、<code>double</code>）的默认值为<code>0</code>。</li><li>引用类型的默认值为<code>null</code>。</li><li>常量的默认值为我们程序中设定的值，比如我们在程序中定义<code>final static int a = 100</code>，则准备阶段中<code>a</code>的初值就是<code>100</code>。</li></ul><h3 id="_2-3-解析" tabindex="-1"><a class="header-anchor" href="#_2-3-解析"><span>2.3 解析</span></a></h3><p>这一阶段的任务就是把常量池中的<strong>符号引用</strong>转换为<strong>直接引用</strong>。</p><h2 id="_3-初始化" tabindex="-1"><a class="header-anchor" href="#_3-初始化"><span>3. 初始化</span></a></h2><p>类初始化阶段是类加载过程的最后一步。而也是到了该阶段，才真正开始执行类中定义的Java程序代码（字节码），之前的动作都由虚拟机主导。</p><p>类的初始化时机：只有当类被直接引用的时候，才会触发类的初始化。</p><h3 id="_3-1-类被直接引用的情况" tabindex="-1"><a class="header-anchor" href="#_3-1-类被直接引用的情况"><span>3.1 类被直接引用的情况</span></a></h3><p>通过以下几种方式：</p><ol><li><code>new</code>关键字创建对象。</li><li>读取或设置类的静态变量。</li><li>调用类的静态方法。</li><li>通过反射方式执行1里面的三种方式。</li><li>初始化子类的时候，会触发父类的初始化。</li><li>作为程序入口直接运行时（调用<code>main</code>方法）。</li><li>接口实现类初始化的时候，会触发直接或间接实现的所有接口的初始化。</li></ol><h3 id="_3-2-类的初始化注意点" tabindex="-1"><a class="header-anchor" href="#_3-2-类的初始化注意点"><span>3.2 类的初始化注意点</span></a></h3><ol><li>类的初始化，会自上而下运行静态代码块或静态赋值语句，非静态与非赋值的静态语句均不执行。</li><li>如果存在父类，则父类先进行初始化，是一个典型的递归模型。</li></ol><p><strong>区别于对象的初始化</strong>：类的初始化所做的一切都是基于类变量或类语句的，也就是说执行的都是共性的抽象信息。而我们知道，类就是对象实例的抽象。</p><h2 id="_4-使用" tabindex="-1"><a class="header-anchor" href="#_4-使用"><span>4. 使用</span></a></h2><p>类的使用分为<strong>直接引用</strong>和<strong>间接引用</strong>。</p><p><strong>直接引用与间接引用等判别条件</strong>：看对该类的引用是否会引起类的初始化。</p><p>类的间接引用，主要有下面几种情况：</p><ul><li>当引用了一个类的静态变量，而该静态变量继承自父类的话，不引起初始化。</li><li>定义一个类的数组，不会引起该类的初始化。</li><li>当引用一个类的常量时，不会引起该类的初始化。</li></ul><h2 id="_5-卸载" tabindex="-1"><a class="header-anchor" href="#_5-卸载"><span>5. 卸载</span></a></h2><ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的<code>ClassLoader</code>已经被回收。</li><li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p>如果以上三个条件全部满足，JVM就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，Java类的整个生命周期就结束了。</p>',38)]))}]]),s=JSON.parse('{"path":"/vue-design-patterns/basics/jvm/class-lifecycle.html","title":"一个类完整的生命周期","lang":"zh-CN","frontmatter":{"description":"一个类完整的生命周期 一个类完整的生命周期，会经历五个阶段，分别为：加载、连接、初始化、使用、和卸载。其中的连接又分为验证、准备和解析。 1. 加载 类的加载阶段就是：找到需要加载的类并把类的信息加载到JVM的方法区中，然后在堆区中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。 类加载其实包括加载、连接、初始化三个阶段。...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/vue-design-patterns/basics/jvm/class-lifecycle.html"}],["meta",{"property":"og:site_name","content":"果然Java封神之路"}],["meta",{"property":"og:title","content":"一个类完整的生命周期"}],["meta",{"property":"og:description","content":"一个类完整的生命周期 一个类完整的生命周期，会经历五个阶段，分别为：加载、连接、初始化、使用、和卸载。其中的连接又分为验证、准备和解析。 1. 加载 类的加载阶段就是：找到需要加载的类并把类的信息加载到JVM的方法区中，然后在堆区中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。 类加载其实包括加载、连接、初始化三个阶段。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-01T10:01:53.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-01T10:01:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"一个类完整的生命周期\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-01T10:01:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈果然\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 加载","slug":"_1-加载","link":"#_1-加载","children":[{"level":3,"title":"1.1 类的理论加载方式","slug":"_1-1-类的理论加载方式","link":"#_1-1-类的理论加载方式","children":[]},{"level":3,"title":"1.2 类的实现加载方式","slug":"_1-2-类的实现加载方式","link":"#_1-2-类的实现加载方式","children":[]}]},{"level":2,"title":"2. 连接","slug":"_2-连接","link":"#_2-连接","children":[{"level":3,"title":"2.1 验证","slug":"_2-1-验证","link":"#_2-1-验证","children":[]},{"level":3,"title":"2.2 准备","slug":"_2-2-准备","link":"#_2-2-准备","children":[]},{"level":3,"title":"2.3 解析","slug":"_2-3-解析","link":"#_2-3-解析","children":[]}]},{"level":2,"title":"3. 初始化","slug":"_3-初始化","link":"#_3-初始化","children":[{"level":3,"title":"3.1 类被直接引用的情况","slug":"_3-1-类被直接引用的情况","link":"#_3-1-类被直接引用的情况","children":[]},{"level":3,"title":"3.2 类的初始化注意点","slug":"_3-2-类的初始化注意点","link":"#_3-2-类的初始化注意点","children":[]}]},{"level":2,"title":"4. 使用","slug":"_4-使用","link":"#_4-使用","children":[]},{"level":2,"title":"5. 卸载","slug":"_5-卸载","link":"#_5-卸载","children":[]}],"git":{"createdTime":1764583313000,"updatedTime":1764583313000,"contributors":[{"name":"chenmingxing","email":"1060303243@qq.com","commits":1}]},"readingTime":{"minutes":4.54,"words":1361},"filePathRelative":"vue-design-patterns/basics/jvm/class-lifecycle.md","localizedDate":"2025年12月1日","excerpt":"\\n<p>一个类完整的生命周期，会经历五个阶段，分别为：<strong>加载、连接、初始化、使用、和卸载</strong>。其中的连接又分为<strong>验证、准备和解析</strong>。</p>\\n<h2>1. 加载</h2>\\n<p>类的加载阶段就是：找到需要加载的类并把类的信息加载到JVM的方法区中，然后在堆区中实例化一个<code>java.lang.Class</code>对象，作为方法区中这个类的信息的入口。</p>\\n<p>类加载其实包括<strong>加载、连接、初始化</strong>三个阶段。类加载强调一个JVM能够直接使用所需的类，所以类必须完成初始化。</p>\\n<h3>1.1 类的理论加载方式</h3>","autoDesc":true}')}}]);