"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[403],{6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},1305:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>y,data:()=>f});var n=a(641);const l=a.p+"assets/img/CgqCHl7OXiqAWO_nAKvmbV2Jtk4891.a41cf519.gif",e=a.p+"assets/img/CgqCHl7OUzqAAxTsAABByswXNGY123.580ae2a5.png",t=a.p+"assets/img/CgqCHl7OU1uAEuxjAABPx98ZMKs566.289faf74.png",p=a.p+"assets/img/Ciqc1F7OU2qAaiymAAA-hJj3ddw282.a18f1324.png",h=a.p+"assets/img/CgqCHl7OU3WAV7lDAAAsQ8fj2Gw000.a8d8c7e2.png",g=a.p+"assets/img/CgqCHl8ESZuADqT5AABRo8Zc6TI733.d2347f66.png",r=a.p+"assets/img/CgqCHl8ESbaAJi2xAAA-XJSjXw4037.6eba9695.png",k=a.p+"assets/img/Ciqc1F7OU6eABdMqACANMndwJA8082.7c667940.gif",d=a.p+"assets/img/CgqCHl7OU8KAME-KABD6y8ZPI78129.93cc75a3.gif",A=a.p+"assets/img/Ciqc1F7OU-KAAnFoADpVNB3lRQQ707.676ef014.gif",o=a.p+"assets/img/CgqCHl7OU_-AVy0YACM7QklhkuQ370.b4bdd9d2.gif",c=a.p+"assets/img/Ciqc1F7OVEaAOjblAGtskMyw3Cc079.f49a7d12.gif",E=a.p+"assets/img/CgqCHl7OVjSAOebFABlVpq6d7m0547.3194ba4c.gif",B=a.p+"assets/img/CgqCHl9HaUOAWgIjAACUx2G0hrE005.f568f084.png",C=a.p+"assets/img/CgqCHl9HaWeAc13rACQBNVWyhLM940.09217ab1.gif",u={},y=(0,a(6262).A)(u,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<p>通过前面课时的学习，我们了解到数据在代码中被处理和加工的最小单位动作是增、删、查。它们是深入学习数据结构的根基，通过“增删查”的操作，我们可以选择更合适的数据结构来解决实际工作中遇到的问题。例如，几个客户端分别向服务端发送请求，服务端要采用先到先得的处理方式，应该如何设计数据结构呢？接下来，从本课时开始，我们将正式开始系统性的学习数据结构的内容。</p><h3 id="什么是数据结构" tabindex="-1"><a class="header-anchor" href="#什么是数据结构"><span><strong>什么是数据结构？</strong></span></a></h3><p>首先，我们简单探讨一下什么是数据结构。数据结构，从名字上来看是数据的结构，也就是数据的组织方式。在数据结构适用的场合中，需要有一定量的数据。如果数据都没有，也就不用讨论数据如何组织了。当我们有了一定数量的数据时，就需要考虑以什么样的方式去对这些数据进行组织了。</p><p>接下来，我将通过一个实际案例来帮助你更好地理解数据结构。假设你是一所幼儿园的园长，现在你们正在组织一场运动会，所有的小朋友需要在操场上接受检阅。那么，如何组织小朋友有序站队并完成检阅呢？</p><p>几个可能的方式是，让所有的小朋友站成一横排，或者让小朋友站成方阵，又或者让所有的小朋友手拉手，围成一个大圆圈等等。很显然，这里有无数种可行的组织方式。具体选择哪个组织方式，取决于哪一种能更好地展示出小朋友们的风采。</p><p>试想一下，当计算机要处理大量数据时，同样需要考虑如何去组织这些数据，这就是数据结构。类似于小朋友的站队方式有无数种情况，数据组织的方式也是有无数种可能性。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然而，在实际开发中，经过工程师验证\ufeff并且能有效解决问题的高效率数据结构就比较有限了。事实上，只要我们把这些能真正解决问题的数据结构学会，就足以成为一名合格的软件工程师了。</p><h3 id="什么是线性表" tabindex="-1"><a class="header-anchor" href="#什么是线性表"><span><strong>什么是线性表</strong></span></a></h3><p>好了，铺垫完数据结构的基本概念后，我们就正式进入到这个课程中的第一个数据结构的学习，线性表。</p><p>线性表是 n 个数据元素的有限序列，最常用的是链式表达，通常也叫作线性链表或者链表。在链表中存储的数据元素也叫作结点，一个结点存储的就是一条数据记录。每个结点的结构包括两个部分：</p><ul><li>第一是具体的数据值；</li><li>第二是指向下一个结点的指针。</li></ul><figure><img src="data:image/png;base64,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" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在链表的最前面，通常会有个头指针用来指向第一个结点。对于链表的最后一个结点，由于在它之后没有下一个结点，因此它的指针是个空指针。链表结构，和小朋友手拉手站成一排的场景是非常相似的。</p><p>例如，你需要处理的数据集是 10 个同学考试的得分。如果用链表进行存储，就会得到如下的数据：</p><figure><img src="'+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>仔细观察上图，你会发现这个链表只能通过上一个结点的指针找到下一个结点，反过来则是行不通的。因此，这样的链表也被称作单向链表。</p><p>有时候为了弥补单向链表的不足，我们可以对结点的结构进行改造：</p><ul><li>对于一个单向链表，让最后一个元素的指针指向第一个元素，就得到了循环链表；</li><li>或者把结点的结构进行改造，除了有指向下一个结点的指针以外，再增加一个指向上一个结点的指针。这样就得到了双向链表。</li></ul><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>同样的，还可以对双向链表和循环链表进行融合，就得到了双向循环链表，如下图所示：</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这些种类的链表，都是以单向链表为基础进行的变种。在某些场景下能提高线性表的效率。</p><h3 id="线性表对于数据的增删查处理" tabindex="-1"><a class="header-anchor" href="#线性表对于数据的增删查处理"><span><strong>线性表对于数据的增删查处理</strong></span></a></h3><p>学会了线性表原理之后，我们就来围绕数据的增删查操作，来看看线性表的表现。在这里我们主要介绍单向链表的增删查操作，其他类型的链表与此雷同，我们就不再重复介绍了。</p><p>首先看一下增加操作。如下有一个链表，它存储了 10 个同学的考试成绩。现在发现这样的问题，在这个链表中，有一个同学的成绩忘了被存储进去。假设我们要把这个成绩在红色的结点之后插入，那么该如何进行呢？</p><p>其实，链表在执行数据新增的时候非常容易，只需要把待插入结点的指针指向原指针的目标，把原来的指针指向待插入的结点，就可以了。如下图所示：</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>代码如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们看一下删除操作。还是这个存储了同学们考试成绩的链表，假设里面有一个成绩的样本是被误操作放进来的，我们需要把这个样本删除。链表的删除操作跟新增操作一样，都是非常简单的。如果待删除的结点为 b，那么只需要把指向 b 的指针 （p.next），指向 b 的指针指向的结点（p.next.next）。如下图所示：</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>代码如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>最后，我们再来看看查找操作。我们在前面的课时中提到过，查找操作有两种情况：</p><ul><li>第一种情况是按照位置序号来查找。</li></ul><p>它和数组中的 index 是非常类似的。假设一个链表中，按照学号存储了 10 个同学的考试成绩。现在要查找出学号等于 5 的同学，他的考试成绩是多少，该怎么办呢？</p><p>其实，链表的查找功能是比较弱的，对于这个查找问题，唯一的办法就是一个一个地遍历去查找。也就是，从头开始，先找到学号为 1 的同学，再经过他跳转到学号为 2 的同学。直到经过多次跳转，找到了学号为 5 的同学，才能取出这个同学的成绩。如下图所示：</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>第二种情况是按照具体的成绩来查找。</li></ul><p>同样，假设在一个链表中，存储了 10 个同学的考试成绩。现在要查找出是否有人得分为 95 分。链表的价值在于用指针按照顺序连接了数据结点，但对于每个结点的数值则没有任何整合。当需要按照数值的条件进行查找时，除了按照先后顺序进行遍历，别无他法。</p><p>因此，解决方案是，判断第一个结点的值是否等于 95：</p><ul><li>如果是，则返回有人得分为 95 分；</li><li>如果不是，则需要通过指针去判断下一个结点的值是否等于 95。以此类推，直到把所有结点都访问完。</li></ul><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>根据这里的分析不难发现，链表在新增、删除数据都比较容易，可以在 O(1) 的时间复杂度内完成。但对于查找，不管是按照位置的查找还是按照数值条件的查找，都需要对全部数据进行遍历。这显然就是 O(n) 的时间复杂度。</p><p>虽然链表在新增和删除数据上有优势，但仔细思考就会发现，这个优势并不实用。这主要是因为，在新增数据时，通常会伴随一个查找的动作。例如，在第五个结点后，新增一个新的数据结点，那么执行的操作就包含两个步骤：</p><ul><li>第一步，查找第五个结点；</li><li>第二步，再新增一个数据结点。整体的复杂度就是 O(n) + O(1)。</li></ul><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>根据我们前面所学的复杂度计算方法，这也等同于 O(n) 的时间复杂度。线性表真正的价值在于，它对数据的存储方式是按照顺序的存储。如果数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合些。</p><p>关于数组的知识，我们在后续的课程中会详细展开。</p><h3 id="线性表案例" tabindex="-1"><a class="header-anchor" href="#线性表案例"><span><strong>线性表案例</strong></span></a></h3><p>关于线性表，最高频的问题都会围绕数据顺序的处理。我们在这里给出一些例子来帮助你更好地理解。</p><p>例 1，链表的翻转。给定一个链表，输出翻转后的链表。例如，输入1 -&gt;2 -&gt; 3 -&gt; 4 -&gt;5，输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</p><p>我们来仔细看一下这个问题的难点在哪里，这里有两种情况：</p><ul><li>如果是数组的翻转，这会非常容易。原因在于，数组在连续的空间进行存储，可以直接求解出数组的长度。而且，数组可以通过索引值去查找元素，然后对相应的数据进行交换操作而完成翻转。</li><li>但对于某个单向链表，它的指针结构造成了它的数据通路有去无回，一旦修改了某个指针，后面的数据就会造成失联的状态。为了解决这个问题，我们需要构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。具体如下图所示：</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(curr){</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    next </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> curr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    curr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> prev；</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    prev </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> curr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    curr </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>例 2，给定一个奇数个元素的链表，查找出这个链表中间位置的结点的数值。</p><p>这个问题也是利用了链表的长度无法直接获取的不足做文章，解决办法如下：</p><ul><li>一个暴力的办法是，先通过一次遍历去计算链表的长度，这样我们就知道了链表中间位置是第几个。接着再通过一次遍历去查找这个位置的数值。</li><li>除此之外，还有一个巧妙的办法，就是利用快慢指针进行处理。其中快指针每次循环向后跳转两次，而慢指针每次向后跳转一次。如下图所示。</li></ul><figure><img src="'+E+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(fast </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> fast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> fast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">){</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    fast </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> fast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    slow </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> slow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例 3，判断链表是否有环。如下图所示，这就是一个有环的链表。</p><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>链表的快慢指针方法，在很多链表操作的场景下都非常适用，对于这个问题也是一样。</p><p>假设链表有环，这个环里面就像是一个跑步赛道的操场一样。经过多次循环之后，快指针和慢指针都会进入到这个赛道中，就好像两个跑步选手在比赛。#加动图#快指针每次走两格，而慢指针每次走一格，相对而言，快指针每次循环会多走一步。这就意味着：</p><ul><li>如果链表存在环，快指针和慢指针一定会在环内相遇，即 fast == slow 的情况一定会发生。</li><li>反之，则最终会完成循环，二者从未相遇。</li></ul><p>根据这个性质我们就能对链表是否有环进行准确地判断了。如下图所示：</p><figure><img src="'+C+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><strong>总结</strong></span></a></h3><p>好的，这节课的内容就到这里了。这一节的内容主要围绕线性表的原理、线性表对于数据的增删查操作展开。线性链表结构的每个结点，由数据的数值和指向下一个元素的指针构成。根据结构组合方式的不同，除了单向链表以外，还有双向链表、循环链表以及双向循环链表等变形。</p><p>经过我们的分析，链表在增、删方面比较容易实现，可以在 O(1) 的时间复杂度内完成。但对于查找，不管是按照位置的查找还是按照数值条件的查找，都需要对全部数据进行遍历。</p><p>线性表的价值在于，它对数据的存储方式是按照顺序的存储。当数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。链表的翻转、快慢指针的方法，是你必须掌握的内容。</p><h3 id="练习题" tabindex="-1"><a class="header-anchor" href="#练习题"><span><strong>练习题</strong></span></a></h3><p>最后我们留一道课后练习题。给定一个含有 n 个元素的链表，现在要求每 k 个节点一组进行翻转，打印翻转后的链表结果。其中，k 是一个正整数，且可被 n 整除。</p><p>例如，链表为 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6，k = 3，则打印 321654。我们给出一些提示，这个问题需要使用到链表翻转的算法。</p>',78)]))}]]),f=JSON.parse('{"path":"/column/%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04%20%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8B%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%EF%BC%9F.html","title":"04 如何完成线性表结构下的增删查？","lang":"zh-CN","frontmatter":{"title":"04 如何完成线性表结构下的增删查？","breadcrumb":false,"description":"通过前面课时的学习，我们了解到数据在代码中被处理和加工的最小单位动作是增、删、查。它们是深入学习数据结构的根基，通过“增删查”的操作，我们可以选择更合适的数据结构来解决实际工作中遇到的问题。例如，几个客户端分别向服务端发送请求，服务端要采用先到先得的处理方式，应该如何设计数据结构呢？接下来，从本课时开始，我们将正式开始系统性的学习数据结构的内容。 什么...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/column/%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04%20%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8B%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"凡人修码传"}],["meta",{"property":"og:title","content":"04 如何完成线性表结构下的增删查？"}],["meta",{"property":"og:description","content":"通过前面课时的学习，我们了解到数据在代码中被处理和加工的最小单位动作是增、删、查。它们是深入学习数据结构的根基，通过“增删查”的操作，我们可以选择更合适的数据结构来解决实际工作中遇到的问题。例如，几个客户端分别向服务端发送请求，服务端要采用先到先得的处理方式，应该如何设计数据结构呢？接下来，从本课时开始，我们将正式开始系统性的学习数据结构的内容。 什么..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-03T15:08:54.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-03T15:08:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"04 如何完成线性表结构下的增删查？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-03T15:08:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"韩跑跑\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"什么是数据结构？","slug":"什么是数据结构","link":"#什么是数据结构","children":[]},{"level":3,"title":"什么是线性表","slug":"什么是线性表","link":"#什么是线性表","children":[]},{"level":3,"title":"线性表对于数据的增删查处理","slug":"线性表对于数据的增删查处理","link":"#线性表对于数据的增删查处理","children":[]},{"level":3,"title":"线性表案例","slug":"线性表案例","link":"#线性表案例","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":3,"title":"练习题","slug":"练习题","link":"#练习题","children":[]}],"git":{"createdTime":1764774534000,"updatedTime":1764774534000,"contributors":[{"name":"chenmingxing","email":"1060303243@qq.com","commits":1}]},"readingTime":{"minutes":11.43,"words":3428},"filePathRelative":"column/重学数据结构与算法/04 如何完成线性表结构下的增删查？.md","localizedDate":"2025年12月3日","excerpt":"<p>通过前面课时的学习，我们了解到数据在代码中被处理和加工的最小单位动作是增、删、查。它们是深入学习数据结构的根基，通过“增删查”的操作，我们可以选择更合适的数据结构来解决实际工作中遇到的问题。例如，几个客户端分别向服务端发送请求，服务端要采用先到先得的处理方式，应该如何设计数据结构呢？接下来，从本课时开始，我们将正式开始系统性的学习数据结构的内容。</p>\\n<h3><strong>什么是数据结构？</strong></h3>\\n<p>首先，我们简单探讨一下什么是数据结构。数据结构，从名字上来看是数据的结构，也就是数据的组织方式。在数据结构适用的场合中，需要有一定量的数据。如果数据都没有，也就不用讨论数据如何组织了。当我们有了一定数量的数据时，就需要考虑以什么样的方式去对这些数据进行组织了。</p>","autoDesc":true}')}}]);