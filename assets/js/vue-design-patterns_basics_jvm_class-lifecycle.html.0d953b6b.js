"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[5261],{6262:(i,a)=>{a.A=(i,a)=>{const l=i.__vccOpts||i;for(const[i,n]of a)l[i]=n;return l}},2066:(i,a,l)=>{l.r(a),l.d(a,{comp:()=>p,data:()=>r});var n=l(641);const e=l.p+"assets/img/classlifecycle.107d7dae.png",s=l.p+"assets/img/classloading.5acbd3ab.png",t={},p=(0,l(6262).A)(t,[["render",function(i,a){return(0,n.uX)(),(0,n.CE)("div",null,a[0]||(a[0]=[(0,n.Fv)('<h1 id="类的生命周期" tabindex="-1"><a class="header-anchor" href="#类的生命周期"><span>类的生命周期</span></a></h1><p>一个类完整的生命周期，会经历五个阶段，分别为：加载、连接、初始化、使用、和卸载。其中的连接又分为验证、准备和解析三个步骤。 如下图所示：</p><figure><img src="'+e+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h2 id="_1-加载-loading" tabindex="-1"><a class="header-anchor" href="#_1-加载-loading"><span>1. 加载（Loading）</span></a></h2><p>类的加载阶段是指：根据类的全路径名找到需要加载的类，并把类的信息加载到 JVM 的方法区中，然后在堆区中实例化一个 java.lang.Class 对象，作为方法区中这个类信息的入口。结合 JVM 的内存结构会更容易理解。</p><figure><img src="'+s+'" alt="6581131a4b9bf.png" tabindex="0" loading="lazy"><figcaption>6581131a4b9bf.png</figcaption></figure><p>注意：这里的“加载”特指类加载的第一个阶段，而“类加载”通常包括加载、连接、初始化三个阶段。类加载强调 JVM 能够直接使用所需的类，因此类必须完成初始化。</p><p>类的加载方式比较灵活，主要有以下几种：</p><ul><li>根据类的全路径名找到相应的 class 文件，然后从 class 文件中读取内容（常用）。</li><li>从 jar 文件中读取（常用）。</li><li>从网络中获取，例如过去流行的 Applet。</li><li>根据一定的规则实时生成，比如设计模式中的动态代理模式，根据相应类自动生成代理类。</li><li>从非 class 文件中获取，本质上与从 class 文件获取类似。</li></ul><h2 id="_2-连接-linking" tabindex="-1"><a class="header-anchor" href="#_2-连接-linking"><span>2. 连接（Linking）</span></a></h2><p>连接包括验证、准备和解析三个阶段。</p><h3 id="_2-1-验证" tabindex="-1"><a class="header-anchor" href="#_2-1-验证"><span>2.1 验证</span></a></h3><p>进行类的合法性校验。会对字节码格式、变量与方法的合法性、数据类型的有效性、继承与实现的规范性等进行检查，确保被加载的类能够被 JVM 正常执行。</p><h3 id="_2-2-准备" tabindex="-1"><a class="header-anchor" href="#_2-2-准备"><span>2.2 准备</span></a></h3><p>为类的静态变量分配内存，并设为 JVM 默认的初始值；对于非静态变量，则不会分配内存。简单来说就是分配内存并赋初值。 注意：设置的是 JVM 默认初始值，而不是程序中设定的值。规则如下：</p><ul><li>基本类型（int、long、short、char、byte、boolean、float、double）的默认值为 0。</li><li>引用类型的默认值为 null。</li><li>常量（final static）的默认值为程序中设定的值，例如程序中定义 final static int a = 100，则准备阶段中 a 的初值就是 100。</li></ul><h3 id="_2-3-解析" tabindex="-1"><a class="header-anchor" href="#_2-3-解析"><span>2.3 解析</span></a></h3><p>这一阶段的任务是把常量池中的符号引用转换为直接引用。这样程序在执行时就能直接定位到所引用的类、方法或字段对应的内存地址或偏移量，从而执行相应的操作。 例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> str </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> length </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，str.length() 是一个符号引用，指向 String 类的 length() 方法。在解析阶段，JVM 将这个符号引用解析为 String 类实际 length() 方法的直接引用，以便执行时直接调用。</p><h2 id="_3-初始化-initialization" tabindex="-1"><a class="header-anchor" href="#_3-初始化-initialization"><span>3. 初始化（Initialization）</span></a></h2><p>类初始化阶段是类加载过程的最后一步。只有到了该阶段，才真正开始执行类中定义的 Java 程序代码（字节码），之前的动作都由虚拟机主导。</p><p>JVM 对类的加载时机没有明确规范，但对类的初始化时机有严格规定：只有当类被直接引用时，才会触发类的初始化。类被直接引用的情况有以下几种：</p><ul><li>通过 new 关键字创建对象。</li><li>读取或设置类的静态变量。</li><li>调用类的静态方法。</li><li>通过反射方式调用上述方法。</li><li>初始化子类时，会触发父类的初始化。</li><li>作为程序入口直接运行时（调用 main 方法）。</li><li>接口实现类初始化时，会触发直接或间接实现的所有接口的初始化。</li></ul><p>关于类的初始化，记住以下两点：</p><ol><li>类的初始化会自上而下运行静态代码块或静态赋值语句，非静态语句与非赋值的静态语句均不执行。</li><li>如果存在父类，则父类先进行初始化，这是一个典型的递归模型。</li></ol><p>区别于对象的初始化，类的初始化所做的都是基于类变量或类语句的，即执行共性的抽象信息。</p><h2 id="_4-使用-using" tabindex="-1"><a class="header-anchor" href="#_4-使用-using"><span>4. 使用（Using）</span></a></h2><p>类的使用分为直接引用和间接引用。判别条件是看对该类的引用是否会引起类的初始化。 直接引用已在类的初始化中阐述，不再赘述。间接引用主要有以下几种情况：</p><ol><li>当通过子类引用父类中定义的静态变量时，不会引起子类的初始化。</li><li>定义一个类的数组，不会引起该类的初始化。</li><li>当引用一个类的常量时，不会引起该类的初始化。</li></ol><h2 id="_5-卸载-unloading" tabindex="-1"><a class="header-anchor" href="#_5-卸载-unloading"><span>5. 卸载（Unloading）</span></a></h2><p>当类使用完毕后，就会进入卸载阶段。衡量类使用完毕的标准如下：</p><ul><li>该类所有的实例都已经被回收，即 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>如果以上三个条件全部满足，JVM 就会在方法区垃圾回收的时候对类进行卸载。类的卸载过程就是在方法区中清空类信息，至此 Java 类的整个生命周期结束。</p>',34)]))}]]),r=JSON.parse('{"path":"/vue-design-patterns/basics/jvm/class-lifecycle.html","title":"类的生命周期","lang":"zh-CN","frontmatter":{"description":"类的生命周期 一个类完整的生命周期，会经历五个阶段，分别为：加载、连接、初始化、使用、和卸载。其中的连接又分为验证、准备和解析三个步骤。 如下图所示： image.pngimage.png 1. 加载（Loading） 类的加载阶段是指：根据类的全路径名找到需要加载的类，并把类的信息加载到 JVM 的方法区中，然后在堆区中实例化一个 java.lang...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/vue-design-patterns/basics/jvm/class-lifecycle.html"}],["meta",{"property":"og:site_name","content":"果然Java封神之路"}],["meta",{"property":"og:title","content":"类的生命周期"}],["meta",{"property":"og:description","content":"类的生命周期 一个类完整的生命周期，会经历五个阶段，分别为：加载、连接、初始化、使用、和卸载。其中的连接又分为验证、准备和解析三个步骤。 如下图所示： image.pngimage.png 1. 加载（Loading） 类的加载阶段是指：根据类的全路径名找到需要加载的类，并把类的信息加载到 JVM 的方法区中，然后在堆区中实例化一个 java.lang..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-01T14:24:24.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-01T14:24:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类的生命周期\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-01T14:24:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"陈果然\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 加载（Loading）","slug":"_1-加载-loading","link":"#_1-加载-loading","children":[]},{"level":2,"title":"2. 连接（Linking）","slug":"_2-连接-linking","link":"#_2-连接-linking","children":[{"level":3,"title":"2.1 验证","slug":"_2-1-验证","link":"#_2-1-验证","children":[]},{"level":3,"title":"2.2 准备","slug":"_2-2-准备","link":"#_2-2-准备","children":[]},{"level":3,"title":"2.3 解析","slug":"_2-3-解析","link":"#_2-3-解析","children":[]}]},{"level":2,"title":"3. 初始化（Initialization）","slug":"_3-初始化-initialization","link":"#_3-初始化-initialization","children":[]},{"level":2,"title":"4. 使用（Using）","slug":"_4-使用-using","link":"#_4-使用-using","children":[]},{"level":2,"title":"5. 卸载（Unloading）","slug":"_5-卸载-unloading","link":"#_5-卸载-unloading","children":[]}],"git":{"createdTime":1764583313000,"updatedTime":1764599064000,"contributors":[{"name":"chenmingxing","email":"1060303243@qq.com","commits":2}]},"readingTime":{"minutes":4.55,"words":1364},"filePathRelative":"vue-design-patterns/basics/jvm/class-lifecycle.md","localizedDate":"2025年12月1日","excerpt":"\\n<p>一个类完整的生命周期，会经历五个阶段，分别为：加载、连接、初始化、使用、和卸载。其中的连接又分为验证、准备和解析三个步骤。\\n如下图所示：</p>\\n<figure><figcaption>image.png</figcaption></figure>\\n<h2>1. 加载（Loading）</h2>\\n<p>类的加载阶段是指：根据类的全路径名找到需要加载的类，并把类的信息加载到 JVM 的方法区中，然后在堆区中实例化一个 java.lang.Class 对象，作为方法区中这个类信息的入口。结合 JVM 的内存结构会更容易理解。</p>\\n<figure><figcaption>6581131a4b9bf.png</figcaption></figure>","autoDesc":true}')}}]);