"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[63],{66262:(i,e)=>{e.A=(i,e)=>{const n=i.__vccOpts||i;for(const[i,a]of e)n[i]=a;return n}},2669:(i,e,n)=>{n.r(e),n.d(e,{comp:()=>A,data:()=>b});var a=n(20641);const t=n.p+"assets/img/Ciqc1F_QfyaAFXAQAAD1xkYN7RE683.399694ae.png",l=n.p+"assets/img/Ciqc1F_Qfy2ACkrLAAD2DLkc2qw212.8af74330.png",o=n.p+"assets/img/Ciqc1F_QfzOAYoshAAD34kLRebs212.6cb8be35.png",g=n.p+"assets/img/CgqCHl_QfzmAT3mBAAD1O9cjB1Q393.c128297f.png",r=n.p+"assets/img/Ciqc1F_Qfz6AROaIAAD0oNZDdx0700.6f058f7a.png",p=n.p+"assets/img/CgqCHl_Qf0aASbDHAAD1VJbPv8c632.6eaece4b.png",c=n.p+"assets/img/Ciqc1F_Qf02ALx3yAAD1Zwrli6c436.cda2c5e0.png",d=n.p+"assets/img/Ciqc1F_Qf1SABGoMAAD08byRpJo570.cf84f590.png",s=n.p+"assets/img/Ciqc1F_Qf1qAWZ18AAD0WYzP5nY511.0158686c.png",m=n.p+"assets/img/CgqCHl_Qf1-AWhOjAAD1EwUX7NE880.1098bd14.png",u=n.p+"assets/img/Ciqc1F_Qf2SAdJKAAAD1noNKR4M217.716ec83d.png",f=n.p+"assets/img/CgqCHl_Qf2qAPdCTAAD1YUKiI1s598.0035128f.png",h={},A=(0,n(66262).A)(h,[["render",function(i,e){return(0,a.uX)(),(0,a.CE)("div",null,e[0]||(e[0]=[(0,a.Fv)('<p>本课时我们主要学习线程是如何在 6 种状态之间转换的。</p><h2 id="线程的-6-种状态" tabindex="-1"><a class="header-anchor" href="#线程的-6-种状态"><span><strong>线程的 6 种状态</strong></span></a></h2><p>就像生物从出生到长大、最终死亡的过程一样，线程也有自己的生命周期，在 Java 中线程的生命周期中一共有 6 种状态。</p><ol><li>New（新创建）</li><li>Runnable（可运行）</li><li>Blocked（被阻塞）</li><li>Waiting（等待）</li><li>Timed Waiting（计时等待）</li><li>Terminated（被终止）</li></ol><p>如果想要确定线程当前的状态，可以通过 getState() 方法，并且线程在任何时刻只可能处于 1 种状态。</p><h3 id="new-新创建" tabindex="-1"><a class="header-anchor" href="#new-新创建"><span><strong>New 新创建</strong></span></a></h3><p>下面我们逐个介绍线程的 6 种状态，如图所示，首先来看下左上角的 New 状态。</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>New 表示线程被创建但尚未启动的状态：当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable，也就是状态转换图中中间的这个大方框里的内容。</p><h3 id="runnable-可运行" tabindex="-1"><a class="header-anchor" href="#runnable-可运行"><span><strong>Runnable 可运行</strong></span></a></h3><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Java 中的 Runable 状态对应操作系统线程状态中的两种状态，分别是 Running 和 Ready，也就是说，Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。</p><p>所以，如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接下来，我们来看下 Runnable 下面的三个方框，它们统称为阻塞状态，在 Java 中阻塞状态通常不仅仅是 Blocked，实际上它包括三种状态，分别是 Blocked(被阻塞）、Waiting(等待）、Timed Waiting(计时等待），这三 种状态统称为阻塞状态，下面我们来看看这三种状态具体是什么含义。</p><h3 id="blocked-被阻塞" tabindex="-1"><a class="header-anchor" href="#blocked-被阻塞"><span><strong>Blocked 被阻塞</strong></span></a></h3><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>首先来看最简单的 Blocked，从箭头的流转方向可以看出，从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法，都是一样。</p><p>我们再往右看，当处于 Blocked 的线程抢到 monitor 锁，就会从 Blocked 状态回到Runnable 状态。</p><h3 id="waiting-等待" tabindex="-1"><a class="header-anchor" href="#waiting-等待"><span><strong>Waiting 等待</strong></span></a></h3><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们再看看 Waiting 状态，线程进入 Waiting 状态有三种可能性。</p><ol><li>没有设置 Timeout 参数的 Object.wait() 方法。</li><li>没有设置 Timeout 参数的 Thread.join() 方法。</li><li>LockSupport.park() 方法。</li></ol><p>刚才强调过，Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。</p><p>Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。</p><h3 id="timed-waiting-限期等待" tabindex="-1"><a class="header-anchor" href="#timed-waiting-限期等待"><span><strong>Timed Waiting 限期等待</strong></span></a></h3><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在 Waiting 上面是 Timed Waiting 状态，这两个状态是非常相似的，区别仅在于有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。</p><p>以下情况会让线程进入 Timed Waiting 状态。</p><ol><li>设置了时间参数的 Thread.sleep(long millis) 方法；</li><li>设置了时间参数的 Object.wait(long timeout) 方法；</li><li>设置了时间参数的 Thread.join(long millis) 方法；</li><li>设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。</li></ol><p>讲完如何进入这三种状态，我们再来看下如何从这三种状态流转到下一个状态。</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>想要从 Blocked 状态进入 Runnable 状态，要求线程获取 monitor 锁，而从 Waiting 状态流转到其他状态则比较特殊，因为首先 Waiting 是不限时的，也就是说无论过了多长时间它都不会主动恢复。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>只有当执行了 LockSupport.unpark()，或者 join 的线程运行结束，或者被中断时才可以进入 Runnable 状态。</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 Blocked 状态，这是为什么呢？因为唤醒 Waiting 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 notify()/notifyAll() 的唤醒它的线程执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>同样在 Timed Waiting 中执行 notify() 和 notifyAll() 也是一样的道理，它们会先进入 Blocked 状态，然后抢夺锁成功后，再回到 Runnable 状态。</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当然对于 Timed Waiting 而言，如果它的超时时间到了且能直接获取到锁/join的线程运行结束/被中断/调用了LockSupport.unpark()，会直接恢复到 Runnable 状态，而无需经历 Blocked 状态。</p><h3 id="terminated-终止" tabindex="-1"><a class="header-anchor" href="#terminated-终止"><span><strong>Terminated 终止</strong></span></a></h3><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>再来看看最后一种状态，Terminated 终止状态，要想进入这个状态有两种可能。</p><ul><li>run() 方法执行完毕，线程正常退出。</li><li>出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。</li></ul><h4 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点"><span><strong>注意点</strong></span></a></h4><p>最后我们再看线程转换的两个注意点。</p><ol><li>线程的状态是需要按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。</li><li>线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换。</li></ol>',48)]))}]]),b=JSON.parse('{"path":"/column/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B78%E8%AE%B2-%E5%BE%90%E9%9A%86%E6%9B%A6/03%20%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A86%E7%A7%8D%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%EF%BC%9F.html","title":"03 线程是如何在6种状态之间转换的？","lang":"zh-CN","frontmatter":{"title":"03 线程是如何在6种状态之间转换的？","breadcrumb":false,"description":"本课时我们主要学习线程是如何在 6 种状态之间转换的。 线程的 6 种状态 就像生物从出生到长大、最终死亡的过程一样，线程也有自己的生命周期，在 Java 中线程的生命周期中一共有 6 种状态。 New（新创建） Runnable（可运行） Blocked（被阻塞） Waiting（等待） Timed Waiting（计时等待） Terminated（...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/column/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B78%E8%AE%B2-%E5%BE%90%E9%9A%86%E6%9B%A6/03%20%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A86%E7%A7%8D%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"凡人修码传"}],["meta",{"property":"og:title","content":"03 线程是如何在6种状态之间转换的？"}],["meta",{"property":"og:description","content":"本课时我们主要学习线程是如何在 6 种状态之间转换的。 线程的 6 种状态 就像生物从出生到长大、最终死亡的过程一样，线程也有自己的生命周期，在 Java 中线程的生命周期中一共有 6 种状态。 New（新创建） Runnable（可运行） Blocked（被阻塞） Waiting（等待） Timed Waiting（计时等待） Terminated（..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-12T09:59:48.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-12T09:59:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"03 线程是如何在6种状态之间转换的？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-12T09:59:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"韩跑跑\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"线程的 6 种状态","slug":"线程的-6-种状态","link":"#线程的-6-种状态","children":[{"level":3,"title":"New 新创建","slug":"new-新创建","link":"#new-新创建","children":[]},{"level":3,"title":"Runnable 可运行","slug":"runnable-可运行","link":"#runnable-可运行","children":[]},{"level":3,"title":"Blocked 被阻塞","slug":"blocked-被阻塞","link":"#blocked-被阻塞","children":[]},{"level":3,"title":"Waiting 等待","slug":"waiting-等待","link":"#waiting-等待","children":[]},{"level":3,"title":"Timed Waiting 限期等待","slug":"timed-waiting-限期等待","link":"#timed-waiting-限期等待","children":[]},{"level":3,"title":"Terminated 终止","slug":"terminated-终止","link":"#terminated-终止","children":[]}]}],"git":{"createdTime":1765533588000,"updatedTime":1765533588000,"contributors":[{"name":"chenmingxing","email":"1060303243@qq.com","commits":1}]},"readingTime":{"minutes":5.28,"words":1584},"filePathRelative":"column/Java并发编程78讲-徐隆曦/03 线程是如何在6种状态之间转换的？.md","localizedDate":"2025年12月12日","excerpt":"<p>本课时我们主要学习线程是如何在 6 种状态之间转换的。</p>\\n<h2><strong>线程的 6 种状态</strong></h2>\\n<p>就像生物从出生到长大、最终死亡的过程一样，线程也有自己的生命周期，在 Java 中线程的生命周期中一共有 6 种状态。</p>\\n<ol>\\n<li>New（新创建）</li>\\n<li>Runnable（可运行）</li>\\n<li>Blocked（被阻塞）</li>\\n<li>Waiting（等待）</li>\\n<li>Timed Waiting（计时等待）</li>\\n<li>Terminated（被终止）</li>\\n</ol>\\n<p>如果想要确定线程当前的状态，可以通过 getState() 方法，并且线程在任何时刻只可能处于 1 种状态。</p>","autoDesc":true}')}}]);